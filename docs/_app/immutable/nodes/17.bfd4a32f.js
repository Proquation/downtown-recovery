import{S as Ht,i as jt,s as xt,y as Bt,a as h,k as o,q as a,z as Wt,c as l,l as n,m as s,r as i,h as t,n as g,A as Gt,b as Mt,C as e,D as $t,g as Nt,d as Ft,B as Vt}from"../chunks/index.a4677e45.js";import{H as Rt}from"../chunks/global.cf228f98.js";const Jt=!0,Qt=Object.freeze(Object.defineProperty({__proto__:null,prerender:Jt},Symbol.toStringTag,{value:"Module"}));function Lt(Pt){let y,Q,m,r,k,ee,te,q,ae,ie,D,oe,ne,U,se,re,O,de,he,M,le,ce,P,ue,pe,H,fe,me,j,ve,we,x,ge,ye,B,be,Se,S,_e,_,Te,Ee,W,ze,d,G,Ce,Ae,$,Ie,ke,N,qe,De,p,Ue,T,Oe,Me,E,Pe,He,z,je,xe,C,Be,We,A,Ge,$e,Ne,F,Fe,Ve,V,Re,Je,R,Le,Ye,J,Ke,Qe,b,Xe,I,Ze,et,tt,L,at,it,Y,ot,nt,K,X;return y=new Rt({}),{c(){Bt(y.$$.fragment),Q=h(),m=o("main"),r=o("div"),k=o("h1"),ee=a("Methodology"),te=h(),q=o("p"),ae=a("The recovery metrics on these charts are based on a sample of mobile phone data."),ie=h(),D=o("p"),oe=a("The recovery metrics on the charts and maps are computed by counting the number of unique visitors in a city's downtown area in the specified time period (standardized by region – see ‘Standardization’ section below), and then dividing it by the standardized number of unique visitors during the equivalent time period in 2019."),ne=h(),U=o("p"),se=a("A recovery metric greater than 100% means that the mobile device activity increased from the comparison period. A value less than 100% means the opposite, that the city's downtown has not recovered to pre-COVID activity levels."),re=h(),O=o("h2"),de=a("Downtown Geography Selection"),he=h(),M=o("p"),le=a("Our previous method for creating downtown polygons involved selecting zip codes with the highest job density. Our updated polygon definitions are more precise and do not rely as heavily on administrative or census boundaries, which often do not reflect the actual geographies of cities’ downtowns. To create these new definitions, we used jobs data to identify concentrations of jobs on individual blocks and then drew a polygon around these clusters to represent downtown. (For more details, see an appendix below)."),ce=h(),P=o("h2"),ue=a("Standardization"),pe=h(),H=o("p"),fe=a("Because fluctuations in unique device counts over time may reflect changes in sample sizes from data providers rather than actual changes in activity, we standardized the downtown counts using larger geographies. In our previous method, this was the state (in the U.S.) or province (in Canada). Our updated method instead standardizes the data using core based statistical areas (in the U.S.) and census metropolitan areas (in Canada). Standardization using these smaller areas results in more accurate recovery rates, since a city’s downtown is not affected by the activity patterns of other cities in the same state."),me=h(),j=o("h2"),ve=a("Data Providers & Imputation"),we=h(),x=o("p"),ge=a("Our mobile device data provider, Spectus, sources information from multiple providers. The most reliable source lacks data before May 2021, so we imputed this information using data from other providers (for more details, see appendix below)."),ye=h(),B=o("h2"),be=a("Website:"),Se=h(),S=o("p"),_e=a("This website was built using Svelte with a bit of D3 for the charts. Code is on "),_=o("a"),Te=a("GitHub"),Ee=h(),W=o("div"),ze=h(),d=o("div"),G=o("h1"),Ce=a("Detailed Methodology"),Ae=h(),$=o("h2"),Ie=a("Downtown Geography Selection"),ke=h(),N=o("p"),qe=a("Our previous method for creating downtown polygons involved selecting zip codes with the highest job density. Our updated polygon definitions are more precise and do not rely as heavily on administrative or census boundaries, which often do not reflect the actual geographies of cities’ downtowns."),De=h(),p=o("p"),Ue=a("To create these new definitions, we used jobs data from 2019 ("),T=o("a"),Oe=a("in the U.S."),Me=a(") and 2016 ("),E=o("a"),Pe=a("in Canada"),He=a("). We generated 1 randomly scattered point for every 100 jobs in each block (in the U.S.) or dissemination area (in Canada). We then applied the "),z=o("a"),je=a("HDBSCAN"),xe=a(" algorithm to each city individually to create clusters of points within the city, discarding the points designated as “noise” and tuning the parameters to select a cluster representing each city’s downtown. For this step, we validated these geographies using Google Maps, cities’ own definitions of their downtowns, our personal knowledge of certain cities, and Brookings’ 2023 "),C=o("a"),Be=a("definitions of downtowns"),We=a(" across the U.S. Next, we created a buffer around each point in the cluster and created a polygon from the spatial union of these buffers. Lastly, we formed a "),A=o("a"),Ge=a("concave hull"),$e=a(" around this polygon to create the final downtown area."),Ne=h(),F=o("h2"),Fe=a("Standardization"),Ve=h(),V=o("p"),Re=a("Because fluctuations in unique device counts over time may reflect changes in sample sizes from data providers rather than actual changes in activity, we standardized the downtown counts using larger geographies. In other words, instead of tracking the raw numbers of unique devices in a downtown area over time, we tracked unique device counts in the downtown divided by unique device counts in a larger area."),Je=h(),R=o("p"),Le=a("In our previous method, this “larger area” was the state (in the U.S.) or province (in Canada). Our updated method instead standardizes the data using core based statistical areas (in the U.S.) and census metropolitan areas (in Canada). Standardization using these smaller areas results in more accurate recovery rates, since a city’s downtown is not affected by the activity patterns of other cities in the same state."),Ye=h(),J=o("h2"),Ke=a("Data Providers & Imputation"),Qe=h(),b=o("p"),Xe=a("Spectus, a data provider, sources information from two different providers. Although one provider supplies the counts of mobile phone data between 2019 and 2023 in the US and Canada, the sample size of the data has been significantly declined, which is likely to hinder the accuracy of estimated recovery rates. On the other hand, another provider offers more comprehensive data covering the US and Canada, but this provider does not include Canadian data before May 2021. To address this gap, we employed the Self-Attention-based Imputation for Time Series (SAITS) model developed by "),I=o("a"),Ze=a("Wenjie, David, & Yan in 2023"),et=a(". Before initiating the imputation process, our underlying hypothesis for imputation was that if we had Canadian data before May 2021, it might show trends similar to those in the US and Canadian cities for two providers."),tt=h(),L=o("p"),at=a("The SAITS model, which employs self-attention techniques, is well-known for capturing dependencies in sequential data, similar to its use in language translation. The approach helps identify relationships within time series data and impute missing information based on observed trends. The overall process of SAITS is that it first converts randomly selected observed values into missing values. Through a series of operations, the model results in the predicted missing values. Finally, the model compares the predicted and original values of artificially created missing values, which allows us to estimate the accuracy of the imputation. In this process, the model is trained for imputation, and the successfully trained model can impute the missing data."),it=h(),Y=o("p"),ot=a("We applied the SAITS model to fill in missing data in Canadian cities from Jan 2019 to May 2021, with a focus on normalizing user ratios. To achieve this goal, the weekly normalizing user ratios data of cities in the US and Canada by two providers was built. Observed data was filled with actual values, whereas the missing data was filled with no value. This resulted in a matrix in which the rows and columns showed the week and value of two providers of all study areas, respectively. After preparing the data, we flipped it chronologically and split it into training and test sets. The training set included 70% of the data, and the remaining part served as the test data. Hyperparameters were tuned through grid search, considering the number of iterations, learning rates, and dropout rates. The model's performance was evaluated using Root Mean Squared Error (RMSE). We found that 130 iterations, 0.001 learning rates, and 0.2 dropout rates were the best combination. Based on the trained model using this hyperparameter combination, the missing data was imputed."),nt=h(),K=o("div"),this.h()},l(f){Wt(y.$$.fragment,f),Q=l(f),m=n(f,"MAIN",{});var v=s(m);r=n(v,"DIV",{class:!0});var c=s(r);k=n(c,"H1",{});var rt=s(k);ee=i(rt,"Methodology"),rt.forEach(t),te=l(c),q=n(c,"P",{});var dt=s(q);ae=i(dt,"The recovery metrics on these charts are based on a sample of mobile phone data."),dt.forEach(t),ie=l(c),D=n(c,"P",{});var ht=s(D);oe=i(ht,"The recovery metrics on the charts and maps are computed by counting the number of unique visitors in a city's downtown area in the specified time period (standardized by region – see ‘Standardization’ section below), and then dividing it by the standardized number of unique visitors during the equivalent time period in 2019."),ht.forEach(t),ne=l(c),U=n(c,"P",{});var lt=s(U);se=i(lt,"A recovery metric greater than 100% means that the mobile device activity increased from the comparison period. A value less than 100% means the opposite, that the city's downtown has not recovered to pre-COVID activity levels."),lt.forEach(t),re=l(c),O=n(c,"H2",{});var ct=s(O);de=i(ct,"Downtown Geography Selection"),ct.forEach(t),he=l(c),M=n(c,"P",{});var ut=s(M);le=i(ut,"Our previous method for creating downtown polygons involved selecting zip codes with the highest job density. Our updated polygon definitions are more precise and do not rely as heavily on administrative or census boundaries, which often do not reflect the actual geographies of cities’ downtowns. To create these new definitions, we used jobs data to identify concentrations of jobs on individual blocks and then drew a polygon around these clusters to represent downtown. (For more details, see an appendix below)."),ut.forEach(t),ce=l(c),P=n(c,"H2",{});var pt=s(P);ue=i(pt,"Standardization"),pt.forEach(t),pe=l(c),H=n(c,"P",{});var ft=s(H);fe=i(ft,"Because fluctuations in unique device counts over time may reflect changes in sample sizes from data providers rather than actual changes in activity, we standardized the downtown counts using larger geographies. In our previous method, this was the state (in the U.S.) or province (in Canada). Our updated method instead standardizes the data using core based statistical areas (in the U.S.) and census metropolitan areas (in Canada). Standardization using these smaller areas results in more accurate recovery rates, since a city’s downtown is not affected by the activity patterns of other cities in the same state."),ft.forEach(t),me=l(c),j=n(c,"H2",{});var mt=s(j);ve=i(mt,"Data Providers & Imputation"),mt.forEach(t),we=l(c),x=n(c,"P",{});var vt=s(x);ge=i(vt,"Our mobile device data provider, Spectus, sources information from multiple providers. The most reliable source lacks data before May 2021, so we imputed this information using data from other providers (for more details, see appendix below)."),vt.forEach(t),ye=l(c),B=n(c,"H2",{});var wt=s(B);be=i(wt,"Website:"),wt.forEach(t),Se=l(c),S=n(c,"P",{});var st=s(S);_e=i(st,"This website was built using Svelte with a bit of D3 for the charts. Code is on "),_=n(st,"A",{href:!0});var gt=s(_);Te=i(gt,"GitHub"),gt.forEach(t),st.forEach(t),c.forEach(t),Ee=l(v),W=n(v,"DIV",{class:!0}),s(W).forEach(t),ze=l(v),d=n(v,"DIV",{class:!0});var u=s(d);G=n(u,"H1",{});var yt=s(G);Ce=i(yt,"Detailed Methodology"),yt.forEach(t),Ae=l(u),$=n(u,"H2",{});var bt=s($);Ie=i(bt,"Downtown Geography Selection"),bt.forEach(t),ke=l(u),N=n(u,"P",{});var St=s(N);qe=i(St,"Our previous method for creating downtown polygons involved selecting zip codes with the highest job density. Our updated polygon definitions are more precise and do not rely as heavily on administrative or census boundaries, which often do not reflect the actual geographies of cities’ downtowns."),St.forEach(t),De=l(u),p=n(u,"P",{});var w=s(p);Ue=i(w,"To create these new definitions, we used jobs data from 2019 ("),T=n(w,"A",{href:!0});var _t=s(T);Oe=i(_t,"in the U.S."),_t.forEach(t),Me=i(w,") and 2016 ("),E=n(w,"A",{href:!0});var Tt=s(E);Pe=i(Tt,"in Canada"),Tt.forEach(t),He=i(w,"). We generated 1 randomly scattered point for every 100 jobs in each block (in the U.S.) or dissemination area (in Canada). We then applied the "),z=n(w,"A",{href:!0});var Et=s(z);je=i(Et,"HDBSCAN"),Et.forEach(t),xe=i(w," algorithm to each city individually to create clusters of points within the city, discarding the points designated as “noise” and tuning the parameters to select a cluster representing each city’s downtown. For this step, we validated these geographies using Google Maps, cities’ own definitions of their downtowns, our personal knowledge of certain cities, and Brookings’ 2023 "),C=n(w,"A",{href:!0});var zt=s(C);Be=i(zt,"definitions of downtowns"),zt.forEach(t),We=i(w," across the U.S. Next, we created a buffer around each point in the cluster and created a polygon from the spatial union of these buffers. Lastly, we formed a "),A=n(w,"A",{href:!0});var Ct=s(A);Ge=i(Ct,"concave hull"),Ct.forEach(t),$e=i(w," around this polygon to create the final downtown area."),w.forEach(t),Ne=l(u),F=n(u,"H2",{});var At=s(F);Fe=i(At,"Standardization"),At.forEach(t),Ve=l(u),V=n(u,"P",{});var It=s(V);Re=i(It,"Because fluctuations in unique device counts over time may reflect changes in sample sizes from data providers rather than actual changes in activity, we standardized the downtown counts using larger geographies. In other words, instead of tracking the raw numbers of unique devices in a downtown area over time, we tracked unique device counts in the downtown divided by unique device counts in a larger area."),It.forEach(t),Je=l(u),R=n(u,"P",{});var kt=s(R);Le=i(kt,"In our previous method, this “larger area” was the state (in the U.S.) or province (in Canada). Our updated method instead standardizes the data using core based statistical areas (in the U.S.) and census metropolitan areas (in Canada). Standardization using these smaller areas results in more accurate recovery rates, since a city’s downtown is not affected by the activity patterns of other cities in the same state."),kt.forEach(t),Ye=l(u),J=n(u,"H2",{});var qt=s(J);Ke=i(qt,"Data Providers & Imputation"),qt.forEach(t),Qe=l(u),b=n(u,"P",{});var Z=s(b);Xe=i(Z,"Spectus, a data provider, sources information from two different providers. Although one provider supplies the counts of mobile phone data between 2019 and 2023 in the US and Canada, the sample size of the data has been significantly declined, which is likely to hinder the accuracy of estimated recovery rates. On the other hand, another provider offers more comprehensive data covering the US and Canada, but this provider does not include Canadian data before May 2021. To address this gap, we employed the Self-Attention-based Imputation for Time Series (SAITS) model developed by "),I=n(Z,"A",{href:!0});var Dt=s(I);Ze=i(Dt,"Wenjie, David, & Yan in 2023"),Dt.forEach(t),et=i(Z,". Before initiating the imputation process, our underlying hypothesis for imputation was that if we had Canadian data before May 2021, it might show trends similar to those in the US and Canadian cities for two providers."),Z.forEach(t),tt=l(u),L=n(u,"P",{});var Ut=s(L);at=i(Ut,"The SAITS model, which employs self-attention techniques, is well-known for capturing dependencies in sequential data, similar to its use in language translation. The approach helps identify relationships within time series data and impute missing information based on observed trends. The overall process of SAITS is that it first converts randomly selected observed values into missing values. Through a series of operations, the model results in the predicted missing values. Finally, the model compares the predicted and original values of artificially created missing values, which allows us to estimate the accuracy of the imputation. In this process, the model is trained for imputation, and the successfully trained model can impute the missing data."),Ut.forEach(t),it=l(u),Y=n(u,"P",{});var Ot=s(Y);ot=i(Ot,"We applied the SAITS model to fill in missing data in Canadian cities from Jan 2019 to May 2021, with a focus on normalizing user ratios. To achieve this goal, the weekly normalizing user ratios data of cities in the US and Canada by two providers was built. Observed data was filled with actual values, whereas the missing data was filled with no value. This resulted in a matrix in which the rows and columns showed the week and value of two providers of all study areas, respectively. After preparing the data, we flipped it chronologically and split it into training and test sets. The training set included 70% of the data, and the remaining part served as the test data. Hyperparameters were tuned through grid search, considering the number of iterations, learning rates, and dropout rates. The model's performance was evaluated using Root Mean Squared Error (RMSE). We found that 130 iterations, 0.001 learning rates, and 0.2 dropout rates were the best combination. Based on the trained model using this hyperparameter combination, the missing data was imputed."),Ot.forEach(t),u.forEach(t),nt=l(v),K=n(v,"DIV",{class:!0}),s(K).forEach(t),v.forEach(t),this.h()},h(){g(_,"href","https://github.com/schoolofcities/downtown-recovery"),g(r,"class","text"),g(W,"class","text"),g(T,"href","https://lehd.ces.census.gov/data/"),g(E,"href","http://odesi2.scholarsportal.info/documentation/CENSUS/2016/cen16labour.html"),g(z,"href","https://scikit-learn.org/stable/modules/generated/sklearn.cluster.HDBSCAN.html"),g(C,"href","https://www.brookings.edu/articles/breaking-the-urban-doom-loop-the-future-of-downtowns-is-shared-prosperity/"),g(A,"href","https://shapely.readthedocs.io/en/stable/reference/shapely.concave_hull.html#shapely.concave_hull"),g(I,"href","https://doi.org/10.1016/j.eswa.2023.119619"),g(d,"class","text"),g(K,"class","text")},m(f,v){Gt(y,f,v),Mt(f,Q,v),Mt(f,m,v),e(m,r),e(r,k),e(k,ee),e(r,te),e(r,q),e(q,ae),e(r,ie),e(r,D),e(D,oe),e(r,ne),e(r,U),e(U,se),e(r,re),e(r,O),e(O,de),e(r,he),e(r,M),e(M,le),e(r,ce),e(r,P),e(P,ue),e(r,pe),e(r,H),e(H,fe),e(r,me),e(r,j),e(j,ve),e(r,we),e(r,x),e(x,ge),e(r,ye),e(r,B),e(B,be),e(r,Se),e(r,S),e(S,_e),e(S,_),e(_,Te),e(m,Ee),e(m,W),e(m,ze),e(m,d),e(d,G),e(G,Ce),e(d,Ae),e(d,$),e($,Ie),e(d,ke),e(d,N),e(N,qe),e(d,De),e(d,p),e(p,Ue),e(p,T),e(T,Oe),e(p,Me),e(p,E),e(E,Pe),e(p,He),e(p,z),e(z,je),e(p,xe),e(p,C),e(C,Be),e(p,We),e(p,A),e(A,Ge),e(p,$e),e(d,Ne),e(d,F),e(F,Fe),e(d,Ve),e(d,V),e(V,Re),e(d,Je),e(d,R),e(R,Le),e(d,Ye),e(d,J),e(J,Ke),e(d,Qe),e(d,b),e(b,Xe),e(b,I),e(I,Ze),e(b,et),e(d,tt),e(d,L),e(L,at),e(d,it),e(d,Y),e(Y,ot),e(m,nt),e(m,K),X=!0},p:$t,i(f){X||(Nt(y.$$.fragment,f),X=!0)},o(f){Ft(y.$$.fragment,f),X=!1},d(f){Vt(y,f),f&&t(Q),f&&t(m)}}}class Xt extends Ht{constructor(y){super(),jt(this,y,null,Lt,xt,{})}}export{Xt as component,Qt as universal};
